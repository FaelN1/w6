<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AUREX - Assistente de Agendamento</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f5f5f5;
      color: #333;
    }
    
    h1 {
      color: #4285f4;
      text-align: center;
    }
    
    .container {
      background-color: white;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      margin-bottom: 20px;
    }
    
    .form-group {
      margin-bottom: 15px;
    }
    
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
    }
    
    input[type="text"] {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 16px;
    }
    
    button {
      background-color: #4285f4;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      transition: background-color 0.3s;
    }
    
    button:hover {
      background-color: #3367d6;
    }
    
    .audio-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: center;
      margin: 20px 0;
    }
    
    .record-btn {
      background-color: #ea4335;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .record-btn:hover {
      background-color: #d33426;
    }
    
    .record-btn.recording {
      animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
      0% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.1);
      }
      100% {
        transform: scale(1);
      }
    }
    
    .icon {
      font-size: 24px;
    }
    
    .result {
      margin-top: 20px;
      border-left: 4px solid #4285f4;
      padding-left: 15px;
    }
    
    .error {
      color: #ea4335;
      border-left: 4px solid #ea4335;
    }
    
    .transcript {
      font-style: italic;
      color: #666;
      margin: 10px 0;
    }
    
    .tabs {
      display: flex;
      margin-bottom: 20px;
    }
    
    .tab {
      padding: 10px 20px;
      background-color: #eee;
      border-radius: 4px 4px 0 0;
      cursor: pointer;
    }
    
    .tab.active {
      background-color: white;
      border-bottom: 2px solid #4285f4;
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    #log {
      max-height: 200px;
      overflow-y: auto;
      background-color: #f9f9f9;
      padding: 10px;
      border-radius: 4px;
      font-family: monospace;
    }
  </style>
</head>
<body>
  <h1>AUREX - Assistente de Agendamento</h1>
  
  <div class="tabs">
    <div class="tab active" data-tab="text">Comando de Texto</div>
    <div class="tab" data-tab="voice">Comando de Voz</div>
  </div>
  
  <div class="container tab-content active" id="text-tab">
    <div class="form-group">
      <label for="comando">Digite seu comando:</label>
      <input type="text" id="comando" name="comando" placeholder="Ex: Agendar reuni√£o com Jo√£o amanh√£ √†s 10h">
    </div>
    
    <button id="send-btn" type="button">Enviar Comando</button>
    
    <div id="text-result" class="result" style="display: none;"></div>
  </div>
  
  <div class="container tab-content" id="voice-tab">
    <h2>Comando por Voz</h2>
    <p>Clique no bot√£o abaixo e diga seu comando de agendamento:</p>
    
    <div class="audio-controls">
      <button id="record-btn" class="record-btn">
        <span class="icon">üé§</span>
      </button>
    </div>
    
    <p id="recording-status">Pronto para gravar</p>
    
    <div id="voice-result" class="result" style="display: none;">
      <div class="transcript"></div>
      <div class="response"></div>
    </div>
  </div>
  
  <div class="container">
    <h3>Log de Atividades</h3>
    <div id="log"></div>
  </div>
  
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // Elementos da interface
      const sendBtn = document.getElementById('send-btn');
      const comandoInput = document.getElementById('comando');
      const textResult = document.getElementById('text-result');
      const recordBtn = document.getElementById('record-btn');
      const recordingStatus = document.getElementById('recording-status');
      const voiceResult = document.getElementById('voice-result');
      const tabs = document.querySelectorAll('.tab');
      const tabContents = document.querySelectorAll('.tab-content');
      const logElement = document.getElementById('log');
      
      // Adicionar elemento de √°udio oculto ao final do body
      const audioPlayer = document.createElement('audio');
      audioPlayer.id = 'response-audio';
      audioPlayer.style.display = 'none';
      document.body.appendChild(audioPlayer);
      
      // Vari√°veis para grava√ß√£o de √°udio
      let isRecording = false;
      let mediaRecorder;
      let audioChunks = [];
      
      // Envio de comando de texto
      sendBtn.addEventListener('click', async () => {
        const comando = comandoInput.value.trim();
        
        if (!comando) {
          alert('Por favor, digite um comando v√°lido.');
          return;
        }
        
        log(`üìù Enviando comando: "${comando}"`);
        
        try {
          sendBtn.disabled = true;
          const response = await fetch('/comando', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ comando })
          });
          
          const resultado = await response.json();
          
          if (response.ok) {
            log('‚úÖ Comando processado com sucesso');
            textResult.innerHTML = formatarResultado(resultado);
            textResult.style.display = 'block';
            textResult.scrollIntoView({ behavior: 'smooth' });
            
            // Reproduzir √°udio se dispon√≠vel
            if (resultado.audio && resultado.audio.url) {
              log(`üîä Reproduzindo resposta de √°udio: ${resultado.audio.url}`);
              reproduzirAudio(resultado.audio.url);
            }
          } else {
            log(`‚ùå Erro: ${resultado.error}`);
            textResult.innerHTML = `<p class="error">Erro: ${resultado.error}</p><p>${resultado.detalhes || ''}</p>`;
            textResult.style.display = 'block';
          }
        } catch (error) {
          log(`‚ùå Erro na requisi√ß√£o: ${error}`);
          textResult.innerHTML = `<p class="error">Erro ao processar comando: ${error.message}</p>`;
          textResult.style.display = 'block';
        } finally {
          sendBtn.disabled = false;
        }
      });
      
      // Fun√ß√£o para reproduzir o √°udio recebido
      function reproduzirAudio(audioUrl) {
        audioPlayer.src = audioUrl;
        audioPlayer.onloadedmetadata = () => {
          audioPlayer.play();
        };
        audioPlayer.onerror = (err) => {
          console.error('Erro ao reproduzir √°udio:', err);
          log(`‚ùå Erro ao reproduzir √°udio: ${err.message || 'Falha no carregamento'}`);
        };
      }
      
      // Manipula√ß√£o do microfone
      recordBtn.addEventListener('click', async () => {
        if (!isRecording) {
          // Iniciar grava√ß√£o
          try {
            const stream = await navigator.mediaDevices.getUserMedia({ 
              audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
                channelCount: 1,
                sampleRate: 44100,
                sampleSize: 16
              } 
            });
            
            // Configurar um MediaRecorder com op√ß√µes otimizadas para melhor qualidade
            const options = { 
              mimeType: getBestSupportedMimeType(),
              audioBitsPerSecond: 256000  // Aumentado para 256kbps para melhor qualidade
            };
            log(`üé§ Formato de grava√ß√£o escolhido: ${options.mimeType} (${options.audioBitsPerSecond/1000}kbps)`);
            
            mediaRecorder = new MediaRecorder(stream, options);
            audioChunks = [];
            
            mediaRecorder.addEventListener('dataavailable', event => {
              if (event.data.size > 0) {
                audioChunks.push(event.data);
                log(`üé§ Chunk de √°udio recebido: ${Math.round(event.data.size / 1024)} KB`);
              }
            });
            
            mediaRecorder.addEventListener('stop', () => {
              // Atualizar interface antes de processar
              recordingStatus.textContent = 'Processando √°udio... Pode demorar alguns segundos';
              
              // Criar um √∫nico blob com todo o √°udio gravado
              const audioBlob = new Blob(audioChunks, { type: mediaRecorder.mimeType });
              const audioSize = Math.round(audioBlob.size / 1024);
              log(`üìä Tamanho total do √°udio: ${audioSize} KB, Tipo: ${mediaRecorder.mimeType}`);
              
              // Se o √°udio for muito pequeno, pode ser um erro
              if (audioSize < 1) {
                log('‚ö†Ô∏è √Åudio muito pequeno, possivelmente n√£o foi gravado corretamente');
                recordingStatus.textContent = 'Erro: Nenhum √°udio gravado. Tente novamente.';
                return;
              }
              
              // Enviar √°udio via HTTP POST
              enviarAudioParaProcessamento(audioBlob);
              
              // Parar todos os tracks de √°udio
              stream.getTracks().forEach(track => track.stop());
              
              // Resetar estado de grava√ß√£o
              isRecording = false;
              recordBtn.classList.remove('recording');
              recordBtn.innerHTML = '<span class="icon">üé§</span>';
            });
            
            // Iniciar grava√ß√£o com uma configura√ß√£o de tempo maior para capturar mais contexto
            mediaRecorder.start(500); // Captura chunks maiores (500ms)
            isRecording = true;
            
            // Atualizar interface
            recordBtn.classList.add('recording');
            recordBtn.innerHTML = '<span class="icon">‚èπÔ∏è</span>';
            recordingStatus.textContent = 'Gravando... Clique para parar';
            log('üé§ Iniciando grava√ß√£o de √°udio');
            
          } catch (error) {
            log(`‚ùå Erro ao acessar o microfone: ${error.message}`);
            recordingStatus.textContent = `Erro: ${error.message}`;
          }
        } else {
          // Parar grava√ß√£o e adicionar um pequeno atraso para garantir que o √∫ltimo chunk seja capturado
          if (mediaRecorder && mediaRecorder.state !== 'inactive') {
            // Pausa antes de parar para garantir que o √∫ltimo fragmento seja capturado
            setTimeout(() => {
              mediaRecorder.stop();
              log('üõë Grava√ß√£o finalizada, processando...');
            }, 500);
            recordingStatus.textContent = 'Finalizando grava√ß√£o...';
          }
        }
      });
      
      // Fun√ß√£o para enviar √°udio para o servidor via HTTP
      async function enviarAudioParaProcessamento(audioBlob) {
        try {
          log('üì§ Preparando envio do √°udio para processamento');
          
          // Criar FormData e adicionar o blob de √°udio
          const formData = new FormData();
          formData.append('audio', audioBlob, 'audio.' + getFileExtension(audioBlob.type));
          
          log(`üì§ Enviando √°udio para o servidor (${Math.round(audioBlob.size / 1024)} KB)...`);
          
          // Enviar para a nova rota HTTP
          const response = await fetch('/processar-audio', {
            method: 'POST',
            body: formData
          });
          
          const data = await response.json();
          
          if (response.ok) {
            if (data.tipo === 'resultado') {
              log(`üîä Comando reconhecido: "${data.texto}"`);
              
              // Exibir transcri√ß√£o e resultado
              voiceResult.querySelector('.transcript').textContent = `"${data.texto}"`;
              voiceResult.classList.remove('error');
              
              // Formatar e exibir o resultado
              const resultadoHTML = formatarResultado(data.resultado);
              voiceResult.querySelector('.response').innerHTML = resultadoHTML;
              voiceResult.style.display = 'block';
              
              // Reproduzir √°udio se dispon√≠vel
              if (data.resultado && data.resultado.audio && data.resultado.audio.url) {
                log(`üîä Reproduzindo resposta de √°udio: ${data.resultado.audio.url}`);
                reproduzirAudio(data.resultado.audio.url);
              }
              
              // Scroll para o resultado
              voiceResult.scrollIntoView({ behavior: 'smooth' });
            }
          } else {
            log(`‚ùå Erro: ${data.mensagem}`);
            voiceResult.querySelector('.transcript').textContent = `Ocorreu um erro: ${data.mensagem}`;
            voiceResult.classList.add('error');
            voiceResult.style.display = 'block';
          }
          
          // Atualizar status
          recordingStatus.textContent = 'Pronto para gravar';
          
        } catch (error) {
          log(`‚ùå Erro ao enviar √°udio: ${error.message}`);
          recordingStatus.textContent = `Erro: ${error.message}`;
          
          voiceResult.querySelector('.transcript').textContent = `Erro na comunica√ß√£o: ${error.message}`;
          voiceResult.classList.add('error');
          voiceResult.style.display = 'block';
        }
      }
      
      // Fun√ß√£o para obter extens√£o de arquivo com base no tipo MIME
      function getFileExtension(mimeType) {
        if (mimeType.includes('webm')) return 'webm';
        if (mimeType.includes('ogg')) return 'ogg';
        if (mimeType.includes('mp3') || mimeType.includes('mpeg')) return 'mp3';
        if (mimeType.includes('wav')) return 'wav';
        if (mimeType.includes('mp4')) return 'mp4';
        // Tipo gen√©rico se n√£o for reconhecido
        return 'bin';
      }
      
      // Fun√ß√£o para obter o melhor formato de m√≠dia suportado pelo navegador
      function getBestSupportedMimeType() {
        // Ordenados por qualidade preferencial para transcri√ß√£o
        const types = [
          'audio/wav',
          'audio/webm;codecs=pcm',
          'audio/webm;codecs=opus',
          'audio/mpeg',
          'audio/mp4;codecs=opus',
          'audio/ogg;codecs=opus',
          'audio/webm',
          'audio/ogg',
        ];
        
        for (const type of types) {
          if (MediaRecorder.isTypeSupported(type)) {
            return type;
          }
        }
        
        // Fallback se nenhum tipo espec√≠fico for suportado
        return '';
      }
      
      // Altern√¢ncia entre abas
      tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          const tabId = tab.getAttribute('data-tab');
          
          tabs.forEach(t => t.classList.remove('active'));
          tabContents.forEach(c => c.classList.remove('active'));
          
          tab.classList.add('active');
          document.getElementById(`${tabId}-tab`).classList.add('active');
        });
      });
      
      // Fun√ß√£o para formatar o resultado de forma amig√°vel
      function formatarResultado(resultado) {
        if (!resultado) return '<p>Nenhum resultado retornado</p>';
        
        let html = `<h3>${resultado.message || 'Resultado'}</h3>`;
        
        if (resultado.dados) {
          const { evento, email, registroDb } = resultado.dados;
          
          if (evento) {
            html += `
              <p><strong>Evento:</strong> ${evento.summary}</p>
              <p><strong>Data/Hora:</strong> ${formatarData(evento.start.dateTime)}</p>
              <p><strong>Descri√ß√£o:</strong> ${evento.description || 'Sem descri√ß√£o'}</p>
            `;
            
            if (evento.attendees) {
              html += `<p><strong>Participantes:</strong> ${evento.attendees.map(a => a.email).join(', ')}</p>`;
            }
            
            if (evento.htmlLink) {
              html += `<p><a href="${evento.htmlLink}" target="_blank">Ver no Google Calendar</a></p>`;
            }
          }
          
          if (email) {
            html += `<p><strong>Email:</strong> ${email}</p>`;
          }
          
          if (registroDb) {
            html += `<p><strong>Registro no banco de dados:</strong> ${registroDb ? 'Sucesso' : 'Falha'}</p>`;
          }
        }
        
        // Adicionar bot√£o para reproduzir √°udio novamente se dispon√≠vel
        if (resultado.audio && resultado.audio.url) {
          html += `
            <p>
              <button onclick="document.getElementById('response-audio').play()" class="play-audio-btn">
                üîä Ouvir resposta novamente
              </button>
            </p>
          `;
        }
        
        return html;
      }
      
      // Fun√ß√£o para formatar data
      function formatarData(dataStr) {
        const data = new Date(dataStr);
        return data.toLocaleString('pt-BR', {
          day: '2-digit',
          month: '2-digit',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
      }
      
      // Fun√ß√£o para adicionar ao log
      function log(message) {
        const now = new Date();
        const timestamp = now.toLocaleTimeString('pt-BR');
        const logMessage = `[${timestamp}] ${message}`;
        
        console.log(logMessage);
        
        const logEntry = document.createElement('div');
        logEntry.textContent = logMessage;
        logElement.appendChild(logEntry);
        
        // Manter o scroll no final
        logElement.scrollTop = logElement.scrollHeight;
      }
    });
  </script>
</body>
</html>
